# Default values for s3-resource-operator
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1
image:
  repository: ghcr.io/runningman84/s3-resource-operator
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "1.8.0"
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
podAnnotations: {}
# Uncomment to enable automatic pod restarts when secrets/configmaps change
# Requires Reloader from Stakater: https://github.com/stakater/Reloader
# reloader.stakater.com/auto: "true"
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 2000
  seccompProfile:
    type: RuntimeDefault
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
service:
  type: ClusterIP
  port: 80
ingress:
  enabled: false
  className: ""
  annotations: {}
  # kubernetes.io/ingress.class: nginx
  # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local
resources: {}
# We usually recommend not to specify default resources and to leave this as a conscious
# choice for the user. This also increases chances charts run on environments with little
# resources, such as Minikube. If you do want to specify resources, uncomment the
# following lines, adjust them as necessary, and remove the curly braces after 'resources:'.
# limits:
#   cpu: 100m
#   memory: 128Mi
# requests:
#   cpu: 100m
#   memory: 128Mi

nodeSelector: {}
tolerations: []
affinity: {}
operator:
  # -- Log level for the operator (DEBUG, INFO, WARNING, ERROR, CRITICAL)
  logLevel: "INFO"
  # Annotation key for secrets to be processed by the operator
  # -- The annotation key to look for on secrets.
  annotation_key: "s3-resource-operator.io/enabled"
  # S3 backend to use
  backend_name: "versitygw"
  # Secret management for the operator's own S3 credentials.
  # These are the credentials the operator uses to connect to the S3 endpoint.
  secret:
    # -- Set to true to create a new secret with the credentials below.
    # Set to false to use an existing secret (specify the name below).
    create: true
    # -- Name of the secret containing S3 credentials.
    # If 'create' is true and name is empty, a name will be generated automatically.
    # If 'create' is false, you MUST specify the name of an existing secret.
    # The secret must contain the following keys: S3_ENDPOINT_URL, ROOT_ACCESS_KEY, ROOT_SECRET_KEY
    name: ""
    # -- Data for the new secret (only used if create is true).
    # The keys must be S3_ENDPOINT_URL, ROOT_ACCESS_KEY, and ROOT_SECRET_KEY.
    # Values will be base64-encoded automatically.
    # Example:
    #   S3_ENDPOINT_URL: "http://versitygw.default.svc.cluster.local:7070"
    #   ROOT_ACCESS_KEY: "admin"
    #   ROOT_SECRET_KEY: "your-secret-key"
    data: {}
metrics:
  service:
    enabled: true
    port: 8000
    # Annotations for legacy Prometheus scraping (without Prometheus Operator)
    # These are not needed if you're using ServiceMonitor (serviceMonitor.enabled=true)
    annotations: {}
    # prometheus.io/scrape: "true"
    # prometheus.io/path: "/metrics"
    # prometheus.io/port: "8000"
# ServiceMonitor configuration for Prometheus Operator
serviceMonitor:
  # -- Enable ServiceMonitor for Prometheus Operator
  enabled: false
  # -- Additional labels for ServiceMonitor
  additionalLabels: {}
  # prometheus: kube-prometheus
  # -- Additional annotations for ServiceMonitor
  annotations: {}
  # -- Interval at which metrics should be scraped
  interval: 30s
  # -- Timeout after which the scrape is ended
  scrapeTimeout: 10s
  # -- MetricRelabelConfigs to apply to samples before ingestion
  metricRelabelings: []
  # -- RelabelConfigs to apply to samples before scraping
  relabelings: []
